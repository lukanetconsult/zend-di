# Introduction

## Dependency Injection

Dependency Injection (here-in called DI) refers to the act of providing
dependencies for an object during instantiation or via a method call. A basic
example looks like this:

```php
$b = new MovieLister(new MovieFinder());
```

Above, `MovieFinder` is a dependency of `MovieLister`, and `MovieFinder` was
injected into `MovieLister`.

There are several forms of dependency injection:

- Constructor injection
- Setter injection
- Property (or field) injection

The zend-di component only implements constructor injection. At first to keep the implementation simple,
at second constructor injection has a non-obvious benefit: It enforces the order of initialization
(which helps to prevent circular dependencies) and the completeness of the instaciated object.

If you are not familiar with the concept of DI, here are a couple of great reads:

- [Matthew Weier O'Phinney's Analogy](http://weierophinney.net/matthew/archives/260-Dependency-Injection-An-analogy.html)
- [Ralph Schindler's Learning DI](http://ralphschindler.com/2011/05/18/learning-about-dependency-injection-and-php)
- [Fabien Potencier's Series](http://fabien.potencier.org/article/11/what-is-dependency-injection) on DI


> ### zend-servicemanager
>
> Since zend-di purely provides automatic DI (aka. auto wiring), it does not provide code-driven
> [Inversion of Control](https://en.wikipedia.org/wiki/Inversion_of_control) (IoC).
>
> However, Zend Framework does ship with another IoC component as well: [zend-servicemanager](https://zendframework.github.io/zend-servicemanager/).
> Unlike zend-di, zend-servicemanager is code-driven, meaning that you tell it what class to instantiate,
> or provide a factory for the given class. This allows you a more detailed control on how your objects
> will be instanciated.
>
> In fact zend-di is designed to play nicely with other IoC containers that implement PSR-11,
> especially with zend-servicemanager.
> You can even use factories generated by zend-di for zend-servicemanager.


# Dependency Injection Containers

When your code is written in such a way that all your dependencies are injected
into consuming objects, you might find that the simple act of wiring an object
has gotten more complex. When this becomes the case, and you find that this
wiring is creating more boilerplate code, this makes for an excellent
opportunity to utilize a Dependency Injection Container. These containers are also
often referred to as IoC Containers.

In it's simplest form, a Dependency Injection Container (here-in called a DiC
for brevity), is an object that is capable of creating objects on request and
managing the "wiring", or the injection of required dependencies, for those
requested objects. Since the patterns that developers employ in writing DI
capable code vary, DiC's are generally either in the form of smallish objects
that suit a very specific pattern, or larger DiC frameworks.

The PHP FIG defined a Standard-Interface for such DiCs: The [PSR-11](http://www.php-fig.org/psr/psr-11/)

zend-di is a DiC framework which provides an injector performing the wiring and a
simple imlementation of a DiC. The injector is able to consume any PSR-11 Container,
such as [zend-servicemanager](https://zendframework.github.io/zend-servicemanager/), to obtain the instances of the dependencies.

While for the simplest use cases, no configuration is needed, zend-di allows to
configure how to resolve dependencies for more complex use cases.
